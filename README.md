# 객체 지향 프로그래밍 학습

- 참고 자료
    - [조영호 '오브젝트 - 기초편'](https://inf.run/bwEjW)

# 오브젝트 - 기초편

## 2. 절차적인 설계 개선하기

### 2.1 절차적 설계의 한계와 부수효과

- 절차적 설계는 데이터와 프로세스를 하나로 취급하지 않는다. 따로 분리한다.
    - 작은 프로그램을 만들 때는 직관적이어서 문제가 되지 않는다. 하지만 시스템이 커질수록 문제가 발생한다.
    - 데이터 구조가 변경되면 데이터를 사용하는 모든 프로세스를 찾아 수정해야 한다.
    - 관련 있는 로직이 여러 함수에 흩어져 있으면, 특정 기능을 수정할 때 어디를 수정해야 할지 찾기 어렵고 실수할 확률이 높다.
    - 객체지향은 데이터와 프로세스를 '객체'라는 울타리에 가둔다. 데이터가 변경되어도 울타리 안의 로직만 수정하면 되고, 다른 객체에 영향을 주지 않는 방법이다.
- 부수효과(Side Effect), 여러 프로세스가 동일한 데이터를 공유하면 데이터를 수정할 때 다른 곳에서 예상하지 못한 오류가 발생한다.
- 데이터를 변경할 수 없는 불변 객체(Immutable Object)를 사용하여 예측 가능한 상태를 의도한다.

### 2.2 의존성과 변경의 관계

- 의존성(Dependency)이란 다른 코드가 변경될 때 함께 변경될 수 있는 가능성이다.
- 의존성이 높을수록(강결합) 코드를 변경할 때 연쇄적으로 수정해야 할 곳이 많아진다. 절차적 설계는 데이터의 의존성을 제어하기 어렵기 때문에 변경에 취약하다.

### 2.3 해결책: 데이터와 프로세스의 통합

- 데이터와 데이터를 사용하는 로직을 하나의 단위(객체)로 묶는 캡슐화(Encapsulation)를 통해 문제를 해결할 수 있다.
- 외부에서 객체 내부의 데이터 구조를 알 필요가 없고, 객체가 제공하는 '행위'에만 의존한다.
- 데이터 구조가 변경되어도 객체 내부만 수정하면 되므로 의존성을 차단한다.

### 2.4 설계 철학: 추측에 의한 설계 vs. 책임 주도 설계

- 추측에 의한 설계(Design by Speculation)
- 책임 주도 설계(RDD, Responsibility-Driven Design)

- 엘빈 홀럽(Allen Holub)은 '나중에 사용할 것 같아서' 미리 데이터 접근자(Getter)를 만드는 습관이 캡슐화를 망친다고 비판했다.
- 객체는 데이터 저장소가 아닌 스스로 일을 하는 주체로 봐야 한다. 어떤 객체가 어떤 책임을 져야 하는지 결정하고 책임을 완수하는데 필요한 데이터를 스스로 관리해야 한다.

## 3. 객체지향 기본 원칙

### 3.1 설계의 본질: 변경과의 싸움

- 설계는 변경하기 쉬운 코드를 만들기 위해 필요하다.
- 절차적 설계는 데이터와 로직이 분리되어 데이터 구조를 변경할 때 데이터를 참조하는 모든 로직을 변경해야 한다. 마치 도미노 같다.
- 객체지향 설계는 데이터와 로직을 하나의 '객체'로 묶어, 변경이 발생했을 때 충격을 최소화한다.

### 3.2 패러다임의 전환: 데이터에서 행동으로

- **왜 행동을 우선해야 할까?**
    - 객체지향은 행동(Behavior)에서 시작한다.
    - 데이터를 먼저 결정하면 데이터를 사용하기 위한(Getter/Setter)를 무분별하게 사용한다. 이는 캡슐화를 위배하고 절차적 설계와 다를 바 없는 강한 결합이 발생한다.
    - 객체가 무엇을 하는가에 집중할 때 내부 데이터는 행동을 수행하기 위한 보조 수단에 그친다.

- **책임 주도 설계(Responsibility-Driven Design)**
    - 객체지향의 기본 원칙은 객체를 데이터 덩어리가 아닌 '책임을 가진 존재'로 바라본다.
    - 명령(메시지)을 정의한다.
    - 메시지를 수행하는 책임에 적합한 객체를 선택한다.
    - 객체는 작업을 스스로 결정한다. 외부에서는 결과를 받는다.
- 객체지향 설계는 협력(Collaboration)을 중요시한다.
    - 객체는 자신의 상태를 스스로 관리하고 외부의 간섭을 받지 않는다.
    - 객체는 서로의 내부 상태를 모른 채, 서로가 제공하는 '행동'에 의존한다.

### 3.3 도메인 모델과 표현적 차이의 극복

- 객체지향은 해결하려는 현실 문제(도메인)를 코드 속에 투영하는 노력이다.
- 표현적 차이를 줄이면 비즈니스와 개발자가 작성하는 코드 사이의 간극도 줄어든다. 즉 코드가 설계도며 비즈니스다.

## 3.4 요약

> Tell, Don't Ask

- 내부의 데이터(상태)를 감추고(캡슐화), 외부에는 책임(행동)만 드러내어 변경의 파도를 객체라는 방파제로 막아낸다.

## 4. 책임 할당하기

### 4.1 GRASP(General Responsibility Assigment Software Patterns)

- 객체지향 설계는 어떤 객체에게 어떤 책임을 할당할지를 정하는 것이 핵심이다.
- 객체에게 책임을 할당할 때 참고할 만한 가이드라인, GRASP는 Craig Larman이 제안했다.
- 패턴
    - Information expert(정보 전문가)
    - Creator(창조자)
    - Low coupling(낮은 결합도)
    - High cohesion(높은 응집도)
    - Polymorphism(다형성)
    - Protected variations(변경 보호)

**참고 자료**

- [GRASP (object-oriented design)](https://en.wikipedia.org/wiki/GRASP_(object-oriented_design))

## 5. 객체지향 구현

### 5.1 추상 클래스와 인터페이스

객체지향 설계에서 추상 클래스(Abstract Class)와 인터페이스(Interface)는 공통점을 묶고 확장하기 위한 핵심 개념이다. 
하지만 목적과 사용 의도는 명확히 다르다.

```java
public abstract class Payment {
    
    protected long amount;
    
    // 공통 로직
    public void validate() {
        if (amount <= 0) {
            throw new IllegalArgumentException("잔액이 부족합니다.");
        }
    }
    
    // 구체적인 결제 방식은 자식 클래스가 구현해야 한다.
    public abstract void process();
}

public class CardPayment extends Payment {
    
    @Override
    public void process() {
        // 결제 방식
    }
}
```

- 추상클래스란 여러 클래스가 공유하는 공통 상태와 기본 동작을 담는 부모 클래스다.
- 확장을 전제로 한 설계: 상속을 통해 기능을 구체화한다.
- 공통된 상태와 행위를 제공: 필드와 메서드를 가질 수 있다.
- 기본 구현 + 강제 구현을 함께 제공: 공통 로직은 부모가 제공하고 세부 구현은 자식(`abstract method`)에게 위임한다.

```java
public interface MessageSendable {
    
    void send(String message);
}

public class EmailService implements MessageSendable {
    
    @Override
    public void send(String message) {
        // 이메일 전송 로직
    }
}
```

- 인터페이스란 클래스가 반드시 지켜야 할 행위(약할)를 정의한 계약서다.
- 구현 방법에는 관심을 두지 않고 무엇을 할 수 있는지만 정의한다.
- 상태를 가지지 않는다.
- 여러 역할을 동시에 부여할 수 있다.
- 구현체 간 결합도를 낮추는 목적으로 사용한다.

**<참고 자료>**

- [Dev.java 'Abstract Methods and Classes'](https://dev.java/learn/inheritance/abstract-classes/)

### 5.3 메시지와 메서드

메시지와 메서드는 캡슐화를 이해할 때 자주 사용하는 용어다.

- 메시지(Message): 객체에게 전달하는 '의도'다. 행위 자체를 의미한다. 호출자는 수신자가 어떻게 행동할 지 신경쓰지 않는다.
- 메서드(Method): 메시지를 수신한 객체가 '실제로 실행하는 구체적인 코드'를 의미한다. 메시지를 받고 실제로 표현하는 내용을 의미한다.
- 객체지향 설계는 '어떤 메서드를 만들까?'가 아닌 '어떤 메시지를 주고 받을까?'를 우선 고민해야 한다.

### 5.4 도메인 로직 vs. 애플리케이션 로직

- 도메인 로직(Domain Logic)
    - 비즈니스 자체의 규칙, 현실 세계의 비즈니스 정책을 반영
    - 단위 테스트로 빠르게 검증
- 애플리케이션 로직(Application Logic)
    - 시스템 운영을 위한 흐름, 인프라(DB, 외부 API)와 도메인을 연결
    - Mocking 또는 통합 테스트로 검증
