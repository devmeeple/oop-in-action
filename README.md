# 객체 지향 프로그래밍 학습

- 참고 자료
    - [조영호 '오브젝트 - 기초편'](https://inf.run/bwEjW)

# 오브젝트 - 기초편

## 2. 절차적인 설계 개선하기

### 2.1 절차적 설계의 한계와 부수효과

- 절차적 설계는 데이터와 프로세스를 하나로 취급하지 않는다. 따로 분리한다.
    - 작은 프로그램을 만들 때는 직관적이어서 문제가 되지 않는다. 하지만 시스템이 커질수록 문제가 발생한다.
    - 데이터 구조가 변경되면 데이터를 사용하는 모든 프로세스를 찾아 수정해야 한다.
    - 관련 있는 로직이 여러 함수에 흩어져 있으면, 특정 기능을 수정할 때 어디를 수정해야 할지 찾기 어렵고 실수할 확률이 높다.
    - 객체지향은 데이터와 프로세스를 '객체'라는 울타리에 가둔다. 데이터가 변경되어도 울타리 안의 로직만 수정하면 되고, 다른 객체에 영향을 주지 않는 방법이다.
- 부수효과(Side Effect), 여러 프로세스가 동일한 데이터를 공유하면 데이터를 수정할 때 다른 곳에서 예상하지 못한 오류가 발생한다.
- 데이터를 변경할 수 없는 불변 객체(Immutable Object)를 사용하여 예측 가능한 상태를 의도한다.

### 2.2 의존성과 변경의 관계

- 의존성(Dependency)이란 다른 코드가 변경될 때 함께 변경될 수 있는 가능성이다.
- 의존성이 높을수록(강결합) 코드를 변경할 때 연쇄적으로 수정해야 할 곳이 많아진다. 절차적 설계는 데이터의 의존성을 제어하기 어렵기 때문에 변경에 취약하다.

### 2.3 해결책: 데이터와 프로세스의 통합

- 데이터와 데이터를 사용하는 로직을 하나의 단위(객체)로 묶는 캡슐화(Encapsulation)를 통해 문제를 해결할 수 있다.
- 외부에서 객체 내부의 데이터 구조를 알 필요가 없고, 객체가 제공하는 '행위'에만 의존한다.
- 데이터 구조가 변경되어도 객체 내부만 수정하면 되므로 의존성을 차단한다.

### 2.4 설계 철학: 추측에 의한 설계 vs. 책임 주도 설계

- 추측에 의한 설계(Design by Speculation)
- 책임 주도 설계(RDD, Responsibility-Driven Design)

- 엘빈 홀럽(Allen Holub)은 '나중에 사용할 것 같아서' 미리 데이터 접근자(Getter)를 만드는 습관이 캡슐화를 망친다고 비판했다.
- 객체는 데이터 저장소가 아닌 스스로 일을 하는 주체로 봐야 한다. 어떤 객체가 어떤 책임을 져야 하는지 결정하고 책임을 완수하는데 필요한 데이터를 스스로 관리해야 한다.

## 3. 객체지향 기본 원칙

### 3.1 설계의 본질: 변경과의 싸움

- 설계는 변경하기 쉬운 코드를 만들기 위해 필요하다.
- 절차적 설계는 데이터와 로직이 분리되어 데이터 구조를 변경할 때 데이터를 참조하는 모든 로직을 변경해야 한다. 마치 도미노 같다.
- 객체지향 설계는 데이터와 로직을 하나의 '객체'로 묶어, 변경이 발생했을 때 충격을 최소화한다.

### 3.2 패러다임의 전환: 데이터에서 행동으로

- **왜 행동을 우선해야 할까?**
    - 객체지향은 행동(Behavior)에서 시작한다.
    - 데이터를 먼저 결정하면 데이터를 사용하기 위한(Getter/Setter)를 무분별하게 사용한다. 이는 캡슐화를 위배하고 절차적 설계와 다를 바 없는 강한 결합이 발생한다.
    - 객체가 무엇을 하는가에 집중할 때 내부 데이터는 행동을 수행하기 위한 보조 수단에 그친다.

- **책임 주도 설계(Responsibility-Driven Design)**
    - 객체지향의 기본 원칙은 객체를 데이터 덩어리가 아닌 '책임을 가진 존재'로 바라본다.
    - 명령(메시지)을 정의한다.
    - 메시지를 수행하는 책임에 적합한 객체를 선택한다.
    - 객체는 작업을 스스로 결정한다. 외부에서는 결과를 받는다.
- 객체지향 설계는 협력(Collaboration)을 중요시한다.
    - 객체는 자신의 상태를 스스로 관리하고 외부의 간섭을 받지 않는다.
    - 객체는 서로의 내부 상태를 모른 채, 서로가 제공하는 '행동'에 의존한다.

### 3.3 도메인 모델과 표현적 차이의 극복

- 객체지향은 해결하려는 현실 문제(도메인)를 코드 속에 투영하는 노력이다.
- 표현적 차이를 줄이면 비즈니스와 개발자가 작성하는 코드 사이의 간극도 줄어든다. 즉 코드가 설계도며 비즈니스다.

## 3.4 요약

> Tell, Don't Ask

- 내부의 데이터(상태)를 감추고(캡슐화), 외부에는 책임(행동)만 드러내어 변경의 파도를 객체라는 방파제로 막아낸다.

## 4. 책임 할당하기

### 4.1 GRASP(General Responsibility Assigment Software Patterns)

- 객체지향 설계는 어떤 객체에게 어떤 책임을 할당할지를 정하는 것이 핵심이다.
- 객체에게 책임을 할당할 때 참고할 만한 가이드라인, GRASP는 Craig Larman이 제안했다.
- 패턴
    - Information expert(정보 전문가)
    - Creator(창조자)
    - Low coupling(낮은 결합도)
    - High cohesion(높은 응집도)
    - Polymorphism(다형성)
    - Protected variations(변경 보호)

**참고 자료**

- [GRASP (object-oriented design)](https://en.wikipedia.org/wiki/GRASP_(object-oriented_design))
