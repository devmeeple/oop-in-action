# 5. 의존과 DI

## 의존

- 기능 구현을 위해 다른 구성요소를 사용하는 것을 `의존`이라 한다.
    - 예) 객체 생성, 메서드 호출, 데이터 사용
- 의존은 변경이 전파될 가능성을 의미한다.
    - 의존하는 대상이 변경되면 사용하던 객체(나)도 변경될 가능성이 높아진다.
        - 예) 호출하는 메서드의 파라미터가 변경
        - 예) 호출하는 메서드가 발생할 수 있는 Exception 타입 추가

**따라서 순환 의존은 위험하다.** 순환 의존은 변경에 따른 연쇄 전파 가능성을 가지고 있다.

- 클래스, 패키지, 모듈 등 모든 수준에서 순환 의존이 없도록 해야한다.

의존하는 대상이 많다는 것은 변경될 여지가 많다. 가능하다면 의존하는 대상은 적어야 한다.

### 의존대상이 많을 때

1. 기능이 많은 경우
    - 한 클래스에서 많은 기능을 제공하는 경우 각 기능마다 의존하는 대상이 다를 수 있다.
    - 한가지 기능의 변경이 다른 기능에 영향을 줄 수 있다. (테스트도 힘들다.)
    - 이때 기능별로 분리하는 방법이 있다. 클래스의 갯수는 많아지겠지만 클래스의 의존성은 낮아진다.

2. 묶어보기
    - 몇 가지 의존 대상을 단일 기능으로 묶어 생각하면 의존 대상을 줄일 수 있다. 예) 기능 구현을 추상화

### 의존 대상 객체를 직접 생성하면? 🔥

- 생성 클래스가 바뀌면 의존하는 코드도 바뀐다. (추상화에서 언급)
- 의존 대상 객체를 직접 생성하지 않는 방법
    - 팩토리, 빌더,
    - 의존 주입(Dependency Injection)
    - 서비스 로케이터(Service Locator)

## 의존 주입(Dependency Injection)

- DI는 외부에서 의존 객체를 주입한다.
    - 생성자나 메서드를 활용해서 주입한다.
- 프로그램을 시작하는 메인 메소드에서 의존 객체를 생성하고 주입 할 수도 있지만 보통 `조립기(Assembler)`를 사용한다.
    - 예) NestJS Module

### 장점

1. 상위 타입을 사용할 경우 의존 대상이 변경되면 조립기(설정)만 변경하면 된다.
2. 의존하는 객체 없이 대역 객체를 사용해서 테스트 가능하다.

> DI를 습관처럼 사용하자. 의존 객체는 주입 받도록 코드 작성하는 습관을 기르자.
